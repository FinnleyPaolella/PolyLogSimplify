(* ::Package:: *)

(* ::Input::Initialization:: *)
BeginPackage["PolyLogSimplify`"];


(* ::Input::Initialization:: *)
Conj::usage = "Conj[a] returns the conjugate of a, changing the coefficients rather than the number field if a is an algebraic number.";


(* ::Input::Initialization:: *)
InRealEmbeddings::usage = "InRealEmbeddings[expr] returns a list of expressions where the algebraic numbers in expr have been put into the different real embeddings.";
InComplexEmbeddings::usage = "InComplexEmbeddings[expr] returns a list of expressions where the algebraic numbers in expr have been put into the different complex embeddings (without embeddings conjugate to each other).";
InRealAndComplexEmbeddings::usage = "InRealAndComplexEmbeddings[expr] returns a list of expressions where the algebraic numbers in expr have been put into the different real and complex embeddings (without embeddings conjugate to each other).";


(* ::Input::Initialization:: *)
Li2::usage="Li2[x] represents PolyLog[2,x].";
ReLi2::usage="ReLi2[x] represents Re[PolyLog[2,x]].";
ImLi2::usage="ImLi2[x] represents Im[PolyLog[2,x]].";
D2::usage="D2[x] represents the single-valued Bloch-Wigner dilogarithm";
ND2::usage="ND2[x] gives the representation of D2[x] in terms of PolyLog and Log.";
Li3::usage="Li3[x] represents PolyLog[3,x]";
ReLi3::usage="ReLi3[x] represents Re[PolyLog[3,x]]";
ImLi3::usage="Imi3[x] represents Im[PolyLog[3,x]]";
D3::usage="D3[x] represents the single-valued trilogarithm.";
ND3::usage = "ND3[x] gives the representation of D3[x] in terms of PolyLog and Log.";
N100::usage="N100[x] is equivalent to N[x,{Infinity,x}] (100 places of accuracy).";


(* ::Input::Initialization:: *)
sLi2::usage = "sLi2[x] uses the symmetries to evalute to an expression with Li2[y] where y is the representative of the symmetry class of x.";
sImLi2::usage = "sImLi2[x] uses the symmetries to evalute to an expression with ImLi2[y] where y is the representative of the symmetry class of x.";
sReLi2::usage = "sReLi2[x] uses the symmetries to evalute to an expression with ReLi2[y] where y is the representative of the symmetry class of x.";
sD2::usage = "sD2[x] uses the symmetries to evalute to an expression with D2[y] where y is the representative of the symmetry class of x.";
sD2NoConj::usage = "sD2NoConj[x] uses the symmetries (except the conjugation symmetry) to evalute to an expression with D2[y] where y is the representative of the symmetry class of x.";
sLi3::usage = "sLi3[x] uses the symmetries to evalute to an expression with Li3[y] where y is the representative of the symmetry class of x.";
sReLi3::usage = "sReLi3[x] uses the symmetries to evalute to an expression with ReLi3[y] where y is the representative of the symmetry class of x.";
sImLi3::usage = "sImLi3[x] uses the symmetries to evalute to an expression with ImLi3[y] where y is the representative of the symmetry class of x.";
sD3::usage = "sD3[x] uses the symmetries to evalute to an expression with D3[y] where y is the representative of the symmetry class of x.";


(* ::Input::Initialization:: *)
EquivalentArgumentsLi2::usage= "EquivalentArgumentsLi2[z] gives the list {z,1/z,1-z,1/(1-z),z/(z-1),1-1/z}";
EquivalentArgumentsLi3::usage="EquivalentArgumentsLi3[z] gives the list {z,1/z}";
EquivalentArgumentsD2::usage = "EquivalentArgumentsD2[z] gives the list Join[A,Conj/@A] where A={z,1/z,1-z,1/(1-z),z/(z-1),1-1/z}.";
EquivalentArgumentsD3::usage = "EquivalentArgumentsD3[z] gives the list {z,1/z,Conj[z],Conj[1/z]}.";


(* ::Input::Initialization:: *)
LogSimplify::usage = "LogSimplify[expr] reduces the number of different logarithms in expr as much as possible.";


(* ::Input::Initialization:: *)
PreprocessTrilogsAndDilogs::usage = "PreprocessTrilogsAndDilogs[expr] converts all trilogs and dilogs to ImLi3, D3, ReLi2, D2 and applies the symmetries.";


(* ::Input::Initialization:: *)
DuplicationRelationD2::usage = "DuplicationRelationD2[x] gives a relation with value 0.";
FiveTermRelationD2::usage="FiveTermRelationD2[x,y] gives a relation with value 0.";
DuplicationRelationD3::usage = "DuplicationRelationD3[x] gives a relation with value 0.";
ThreeTermRelationD3::usage = "ThreeTermRelationD3[x] gives a relation with value 0.";
NineTermRelationD3::usage = "NineTermRelationD3[x,y] gives a relation with value 0.";
TwentyTwoTermRelationD3::usage="TwentyTwoTermRelationD3[x,y,z] gives a relation with value 0.";
DistributionRelationD2::usage = "DistributionRelationD2[n,gen][x] gives the distribution relation of order n, where the appearing roots of unity are expressed in the number field generated by gen.";
DistributionRelationD3::usage = "DistributionRelationD3[n,gen][x] gives the distribution relation of order n, where the appearing roots of unity are expressed in the number field generated by gen.";
GetDistributionRelationsD2::usage="GetDistributionRelationsD2[n, gen] gives the distribution relations for all divisor of n.";
GetDistributionRelationsD3::usage="GetDistributionRelationsD3[n, gen] gives the distribution relations for all divisor of n.";


(* ::Input::Initialization:: *)
Beta2::usage = "Beta2[expr] returns the symbol corresponding to the dilogarithm expression.";
Beta3::usage = "Beta3[expr] returns the symbol corresponding to the trilogarithm expression.";


(* ::Input::Initialization:: *)
TensorExpandRationalFunctions::usage="TensorExpandRationalFunctions[expr] expands an expression Tensor[MultElt[f],Mult[g],...] + ... where f,g are rational functions";


(* ::Input::Initialization:: *)
IndependentRelationsWithContractions::usage = "IndependentRelationsWithContractions[relationList,relatedArguments,F->sF] returns a list of all independent relations and contractions built from the relationList using the symmetries provided.";


(* ::Input::Initialization:: *)
ElementOfG2::usage = "ElementOfG2[expr] verifies wether a rational linear combination of D2[_] corresponds to an element in G_2 = A_2";
ElementOfA2::usage = "ElementOfA2[expr] verifies wether a rational linear combination of D2[_] corresponds to an element in G_2 = A_2";
ZeroInB2::usage = "ZeroInB2[expr] verifies wether a linear combination of D2[_] corresponds to a torsion element in B2 by attempting to write it as a linear combination of the five-term relation. Returns unevaluted if no such combination is found.";
ElementOfG3::usage = "ElementOfG3[expr] verifies wether a rational linear combination of D3[_] corresponds to an elment in G_3";
ElementOfA3::usage = "ElementOfA3[expr] verifies wether a rational linear combination of D3[_] corresponds to an elment in A_3";


(* ::Input::Initialization:: *)
SeperateZeroSubexpression::usage="SeperateZeroSubexpression[expr,relationList,F->sF] numerically seperates the expression into multiple expressions equaling zero with fewer terms; uses the symmetry F->sF.";
GreedySimplify::usage="GreedySimplify[expr,relationList,F->sF] reduces the number of terms of F by greedily subtracting relations; uses the symmetry F->sF.";


(* ::Input::Initialization:: *)
SimplifyAllTermsOneIteration::usage = "SimplifyAllTermsOneIteration[expr,relationList,F->sF] attempts to eliminate all F terms in expr using the functional equations from relationList and the symmetry F->sF. See examples to understand what is meant.";
SimplifyAllTerms::usage = "SimplifyAllTerms[expr,plan,F->sF] attempts to eliminate all F terms in expr. plan should be a list with an association for each iteration, specifying relations, newArguments and linearSolve to be used in that iteration. See examples to understand what is meant.";


(* ::Input::Initialization:: *)
Certificate::usage="Certificate is a symbol used in the return value of the simplification routine if the option ReturnCertificate is set to True";
ReturnCertificate::usage = "ReturnCertificate -> True can be given as an option to the simplification routines."


(* ::Input::Initialization:: *)
NewArgumentsFirstIteration::usage = "NewArgumentsFirstIteration should be provided as newArguments function in the first iteration of SimplifyAllTerms.";
NewArgumentsSecondIterationAll::usage = "NewArgumentsSecondIterationAll can be provided as newArguments function in the second iteration of SimplifyAllTerms, does not apply any heuristics.";
NewArgumentsSecondIterationWithCutoff::usage = "NewArgumentsSecondIterationWithCutoff[#1,#2,cutoff]& can be provided as newArguments function in the second iteration of SimplifyAllTerms, only uses arguments which appear in relations with no more than cutoff new arguments.";
LinearSolveStandard::usage = "LinearSolveStandard can be provided as linear solve function to SimplifyAllTerms; does not apply any heuristics.";
LinearSolveWithCutoff::usage="LinearSolveWithCutoff[#1,#2,{a_1,...,a_n},c]& can be provided in the n-th iteration of SimplifyAllTerms as a linear solve function. Relations from iteration i with more than a_i new arguments are discarded and so are relations which contain arguments appearing in less than c other relations.";


(* ::Input::Initialization:: *)
MultElt::usage ="MultElt[z] represents the element z in an abelian group under multiplication, so MultElt[a * b] = MultElt[a] + MultElt[b].";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Subsection::Closed:: *)
(*Conjugate*)


(* ::Input::Initialization:: *)
conjugationTransform::nclosed = "The number field defined by `1` is not closed under complex conjugation. You might want to choose a generator of the number field generated by `1` and its conjugate.";

(* Computing the matrix is computationally rather expensive as ToNumberField can take quit some time. So we use memoization as the number field is typically the same. *)
conjugationTransform[gen_] := conjugationTransform[gen] = With[
    {degreeOfExtension = Length@Last@ToNumberField[gen, gen]},
    If[Quiet@Check[
       ToNumberField[Conjugate[gen], gen]; False,
       True,
       ToNumberField::nnfel
       ],
     
     (* If the number field is not closed under complex conjugation, messages and error and returns unevaluated. *)
     Message[conjugationTransform::nclosed, gen];
     HoldForm[conjugationTransform[gen]],
     
     (* Compute the matrix by which one has to multiply the coefficients to conjugate the number. *)
     Transpose[
      Join[
       {Join[{1}, ConstantArray[0, degreeOfExtension - 1]]}, Table[ToNumberField[Conjugate[gen]^i, gen][[2]], {i, 1, degreeOfExtension - 1}]]
      ]
     ]
    ];

Conj[x_AlgebraicNumber] := AlgebraicNumber[First@x, conjugationTransform[First@x] . Last[x]]; (* First[x] yields the generator, Last[x] yields the coefficients. *)
Conj[x_] := Conjugate[x];
(* If the number is not an Algebraic number, the standard Conjugate is used.*)


(* ::Subsection::Closed:: *)
(*Embeddings*)


(* ::Input::Initialization:: *)
FieldEmbeddings[polynomial_]:=Module[{x,degree,allGenerators,realEmbeddings = {},complexEmbeddings = {},g, cg},
degree=Exponent[polynomial[x],x];
allGenerators=Table[Root[polynomial,i],{i,1,degree}];
While[Length@allGenerators>0,
g=allGenerators[[1]];
cg =Conjugate[g];
If[cg==g,
AppendTo[realEmbeddings,g]; allGenerators=allGenerators[[2;;]],
AppendTo[complexEmbeddings,{g,cg}]; allGenerators=DeleteCases[allGenerators[[2;;]],cg,1]];
];
{realEmbeddings,complexEmbeddings}
];
InDifferentEmbedding::morethanone="Expression contains algebraic numbers with different generators.";
InDifferentEmbedding[expr_,newGenerator_]:=Module[{},
If[Length@Union@Cases[expr,AlgebraicNumber[a_,_]:>a,{0,\[Infinity]}]>1,Message[InDifferentEmbedding::morethanone]];
expr/.AlgebraicNumber[_,x_]:>AlgebraicNumber[newGenerator,x]
];
Clear[InRealAndComplexEmbeddings];
InComplexEmbeddings::onegenerator="Expression must contain algebraic numbers in the same number field.";

InComplexEmbeddings[expr_]:=Module[
{generators=Union@Cases[expr,AlgebraicNumber[a_,_]:>a,{0,\[Infinity]}]},
If[Length@generators!=1,Message[InComplexEmbeddings::onegenerator]];
Map[InDifferentEmbedding[expr,#[[1]]]&,Last[FieldEmbeddings[First@First[generators]]]]/;Length@generators==1
];

InRealEmbeddings[expr_]:=Module[
{generators=Union@Cases[expr,AlgebraicNumber[a_,_]:>a,{0,\[Infinity]}]},
If[Length@generators!=1,Message[InComplexEmbeddings::onegenerator]];
Map[InDifferentEmbedding[expr,#]&,First[FieldEmbeddings[First@First[generators]]]]/;Length@generators==1
];

InRealAndComplexEmbeddings[expr_]:=Module[
{generators=Union@Cases[expr,AlgebraicNumber[a_,_]:>a,{0,\[Infinity]}],
fieldEmbeddings},
If[Length@generators!=1,Message[InComplexEmbeddings::onegenerator]];
(
fieldEmbeddings=FieldEmbeddings[First@First[generators]];
Map[InDifferentEmbedding[expr,#]&,Join[First@fieldEmbeddings,Last[fieldEmbeddings][[All,1]]]]
)/;Length@generators==1
];


(* ::Subsection::Closed:: *)
(*Polylogarithm Symbols*)


(* ::Input::Initialization:: *)
N[Li2[x_],n_:MachinePrecision]:=N[PolyLog[2,x],n];
N[ReLi2[x_],n_:MachinePrecision]:=N[Re@PolyLog[2,x],n];
N[ImLi2[x_],n_:MachinePrecision]:=N[Im@PolyLog[2,x],n];
ND2[1]=0;
ND2[0]=0;
ND2[x_]:=Im[PolyLog[2,x]+Log[1-x] Log[Abs[x]]];
N[D2[x_],n_:MachinePrecision]:=N[ND2[x],n];

N[Li3[x_],n_:MachinePrecision]:=N[PolyLog[3,x],n];
N[ReLi3[x_],n_:MachinePrecision]:=N[Re@PolyLog[3,x],n];
N[ImLi3[x_],n_:MachinePrecision]:=N[Im@PolyLog[3,x],n];
ND3[1]=Zeta[3];
ND3[z_]:=Re[PolyLog[3,z]-PolyLog[2,z]Log[Abs[z]]-1/3 Log[1-z]Log[Abs[z]]^2];
N[D3[x_],n_:MachinePrecision]:=N[ND3[x],n];
N100[x_,n_:100]:=N[x,{\[Infinity],n}];


(* ::Subsection::Closed:: *)
(*Polylogarithms Symmetries*)


(* ::Subsubsection:: *)
(*Li2*)


(* ::Input::Initialization:: *)
(* Calling sLi2[z] on a number that was not seen before will define z as the canonical argument and set the pattern to automatically express sLi2[1-z] as Li2[z] plus some error consisting only of log terms. I think it is better to keep the logarithmic error terms symbolic and only compute them when needed (so we do not compute them for all the relations that are generated). *)
(* sLi2 for symmetric Li2 *)
sLi2[z_]:=(
sLi2[1-z]=-Li2[z]+logTermsOneMinusZ[z];
sLi2[1/z]=-Li2[z]+logTermsOneOverZ[z];
sLi2[1/(1-z)]=Li2[z]+logTermsOneOverOneMinusZ[z];
sLi2[1-1/z]=Li2[z]+logTermsOneMinusOneOverZ[z];
sLi2[z/(z-1)]=-Li2[z]+logTermsZOverZMinusOne[z];
sLi2[z] =Li2[z]);




(* ::Subsubsection:: *)
(*ReLi2*)


(* ::Input::Initialization:: *)
(* we need to define this as a special case, otherwise would get 1/(1-1) when computing the related values *) 
sReLi2[0]=0;
(* sReLi2[1]=\[Pi]^2/6; (* do not need this, is covered by  z==1/(conjugate z)*) *)
(* the following simplifications are for self conjugate arguements. Not all are tested. Note that there are in principal more cases where ReLi2[z] can be reduced,e.g. when z==(1/z). These additional cases are coverd by the three cases here, because the solutions of the additional equations are real so then conjugate does not matter *)


sReLi2[z_/;z==1/Conj[z]]:=sReLi2[z]=1/4 (logTermsOneOverZ[z]+logTermsOneOverZ[Conj@z]);
sReLi2[z_/;z==1-Conj[z]]:=sReLi2[z]=1/4 (logTermsOneMinusZ[z]+logTermsOneMinusZ[Conj@z]);
sReLi2[z_/;z==Conj[z/(z-1)]]:=sReLi2[z]=1/4 (logTermsZOverZMinusOne[z]+logTermsZOverZMinusOne[Conj@z]); 

sReLi2[z_]:=(
sReLi2[1-z]=sReLi2[Conj[1-z]]=-ReLi2[z]+1/2 (logTermsOneMinusZ[z]+logTermsOneMinusZ[Conj@z]);
sReLi2[1/z]=sReLi2[Conj[1/z]]=-ReLi2[z]+1/2 (logTermsOneOverZ[z]+logTermsOneOverZ[Conj@z]);
sReLi2[1/(1-z)]=sReLi2[Conj[1/(1-z)]]=ReLi2[z]+1/2 (logTermsOneOverOneMinusZ[z]+logTermsOneOverOneMinusZ[Conj@z]);
sReLi2[1-1/z]=sReLi2[Conj[1-1/z]]=ReLi2[z]+1/2 (logTermsOneMinusOneOverZ[z]+logTermsOneMinusOneOverZ[Conj@z]);
sReLi2[z/(z-1)]=sReLi2[Conj[z/(z-1)]]=-ReLi2[z]+1/2 (logTermsZOverZMinusOne[z]+logTermsZOverZMinusOne[Conj@z]);
sReLi2[z]=sReLi2[Conj[z]]=ReLi2[z]
);
(* TODO: if argument is real and > 1, then we have problems because of the branchcut. Fix that somehow or at least show warnings. Also do this for Li2 and ImLi2 *)


(* ::Subsubsection:: *)
(*ImLi2*)


(* ::Input::Initialization:: *)
sImLi2[z_/;z===Conj[z]]:=sImLi2[z]=0; (* NOTE: For z>1, this does not hold numerically because there is the Branchcut. TODO: fix this*)
sImLi2[z_]:=(
sImLi2[1-z]=-ImLi2[z]+1/(2I) (logTermsOneMinusZ[z]-logTermsOneMinusZ[Conj@z]);
sImLi2[Conj[1-z]]=-sImLi2[1-z];
sImLi2[1/z]=-ImLi2[z]+1/(2I) (logTermsOneOverZ[z]-logTermsOneOverZ[Conj@z]);
sImLi2[Conj[1/z]]=-sImLi2[1/z];
sImLi2[1/(1-z)]=ImLi2[z]+1/(2I) (logTermsOneOverOneMinusZ[z]-logTermsOneOverOneMinusZ[Conj@z]);
sImLi2[Conj[1/(1-z)]]=-sImLi2[1/(1-z)];
sImLi2[1-1/z]=ImLi2[z]+1/(2I) (logTermsOneMinusOneOverZ[z]-logTermsOneMinusOneOverZ[Conj@z]);
sImLi2[Conj[1-1/z]]=-sImLi2[1-1/z];
sImLi2[z/(z-1)]=-ImLi2[z]+1/(2I) (logTermsZOverZMinusOne[z]-logTermsZOverZMinusOne[Conj@z]);
sImLi2[Conj[z/(z-1)]]=-sImLi2[z/(z-1)];
sImLi2[Conj[z]]=-ImLi2[z];
sImLi2[z]=ImLi2[z]
);


(* ::Subsubsection:: *)
(*D2*)


(* ::Input::Initialization:: *)
sD2[z_/;z===Conj[z]]:=sD2[z]=0;
sD2[z_]:=(
sD2[1-z]=-D2[z];
sD2[Conj[1-z]]=-sD2[1-z];
sD2[1/z]=-D2[z];
sD2[Conj[1/z]]=-sD2[1/z];
sD2[1/(1-z)]=D2[z];
sD2[Conj[1/(1-z)]]=-sD2[1/(1-z)];
sD2[1-1/z]=D2[z];
sD2[Conj[1-1/z]]=-sD2[1-1/z];
sD2[z/(z-1)]=-D2[z];
sD2[Conj[z/(z-1)]]=-sD2[z/(z-1)];
sD2[Conj[z]]=-D2[z];
sD2[z]=D2[z]
);


(* ::Subsubsection:: *)
(*D2NoConj*)


(* ::Input::Initialization:: *)
sD2NoConj[0]=0;
sD2NoConj[1]=0;
sD2NoConj[z_]:=(
sD2NoConj[1-z]=-D2[z];
sD2NoConj[1/z]=-D2[z];
sD2NoConj[1/(1-z)]=D2[z];
sD2NoConj[1-1/z]=D2[z];
sD2NoConj[z/(z-1)]=-D2[z];
sD2NoConj[z]=D2[z]
);


(* ::Subsubsection:: *)
(*Li3 & Error terms*)


(* ::Input::Initialization:: *)
sLi3[z_]:=(
sLi3[1/z]=Li3[z]+logTermsOneOverZLi3[z];
sLi3[z] =Li3[z]);


(* ::Subsubsection:: *)
(*ReLi3*)


(* ::Input::Initialization:: *)
sReLi3[z_]:=(
sReLi3[1/z]=sReLi3[Conj[1/z]]=ReLi3[z]+1/2 (logTermsOneOverZLi3[z]+logTermsOneOverZLi3[Conj@z]);
sReLi3[z]=sReLi3[Conj[z]]=ReLi3[z]
);


(* ::Subsubsection:: *)
(*ImLi3*)


(* ::Input::Initialization:: *)
sImLi3[z_/;z===Conj[z]]:=sImLi3[z]=0; (* NOTE: For z>1, this does not hold numerically because there is the Branchcut. TODO: fix this*)
sImLi3[z_]:=(
sImLi3[1/z]=ImLi3[z]+1/(2I) (logTermsOneOverZLi3[z]-logTermsOneOverZLi3[Conj@z]);
sImLi3[Conj[1/z]]=-sImLi3[1/z];
sImLi3[Conj[z]]=-ImLi3[z];
sImLi3[z]=ImLi3[z]
);


(* ::Subsubsection:: *)
(*D3*)


(* ::Input::Initialization:: *)
sD3[z_]:=(
sD3[1/z]=D3[z];
sD3[Conj[1/z]]=D3[z];
sD3[Conj[z]]=D3[z];
sD3[z]=D3[z]
);


(* ::Subsubsection:: *)
(*Compute the Log terms*)


(* ::Input::Initialization:: *)
(* Compute the logarithmic error terms. NOTE: Not all cases have been checked numerically. *)

(* For the Li2[z]-> -Li2[1/z] + ... rule, there is a branchcut if 0 <= z <= 1. *)ruleOneOverZ={Li2[b_]/;FullSimplify[!(b==Conj[b]&&0<=Re[b]<=1)]:>-Li2[1/b]-1/2 Log[-b]^2-\[Pi]^2/6,Li2[b_]/;FullSimplify[(Im[b]==0&&0<=Re[b]<=1)]:>-Li2[1/b]-1/2 Log[-b]^2-\[Pi]^2/6+2I \[Pi] Log[b]};
ruleMinusOne=Li2[b_]:>-Li2[1-b]-Log[1-b]Log[b]+\[Pi]^2/6; 

logTermsOneMinusZ[z_]:=(Li2[z]/.ruleMinusOne) + Li2[1-z];
logTermsOneOverZ[z_]:=(Li2[z]/.ruleOneOverZ) + Li2[1/z];
logTermsOneOverOneMinusZ[z_]:=-(Li2[z]/.ruleMinusOne/.ruleOneOverZ) + Li2[1/(1-z)];
logTermsOneMinusOneOverZ[z_]:=-(Li2[z]/.ruleOneOverZ/.ruleMinusOne) + Li2[1-1/z];
logTermsZOverZMinusOne[z_]:=(Li2[z]/.ruleOneOverZ/.ruleMinusOne/.ruleOneOverZ) + Li2[z/(z-1)];
logTermsOneOverZLi3[z_]:=1/6 Log[-z]^3+\[Pi]^2/6 Log[-z]/;FullSimplify[!(z==Conj[z]&&0<=Re[z]<=1)];



(* ::Subsection::Closed:: *)
(*Log Simplify*)


(* ::Input::Initialization:: *)
LogSimplifySumRule=a_. Log[b_]+c_. Log[d_]/;Im[a]===Im[c]===0:>Log[b^a d^c]+  Round[a Log[b]+c Log[d]-Log[b^a d^c],2\[Pi] I]; (* This correctly handles the branchcut. *)
simplifyLinearComboOfLogs[expr_]:=If[FreeQ[expr,Log[_]],expr,With[{gcd=GCD@@Cases[Expand@expr,a_. Log[b_]:>a,{1}]},gcd(Expand[expr/gcd]//.LogSimplifySumRule)]]; 

selectLogPart[expr_]:=Select[expr,MatchQ[a_. Log[_]]];
realPrefators[expr_]:=expr /. a_. Log[b_]:>Re[a]Log[b];
imagPrefators[expr_]:=expr /. a_. Log[b_]:>Im[a]Log[b];

(* This function returns True if an epxression of the form a \[Pi] + b_1Log[z_1]+ ... + b_nLog[z_n] equals zero, where a and Subscript[b, i] have rational real and imaginary part. We make use of the function simplifyLinearComboOfLogs, which was defined in the subsection "Converting Li2 to D2i". *)
linearComboOfLogZeroQ[expr_]:=Module[{logPart=selectLogPart[expr], numberPart},
numberPart = expr-logPart//Expand;
FullSimplify[simplifyLinearComboOfLogs[realPrefators[logPart]]+I simplifyLinearComboOfLogs[imagPrefators[logPart]]+numberPart==0]];

getRidOfOneLogArgument::couldnotprove="The relation `1` could not be proven to be zero. Either the relation is not true or the simplification methods are not strong enough.";
getRidOfOneLogArgument[expr_]:=Module[{logTally, rel,relExpr, relPos,leastCommonLog, logToReplace,logPrefactor, rule},
logTally = Tally@Cases[expr,Log[_],{0,\[Infinity]}];
If[Length@logTally==0,Return[expr,Module]];
rel = Quiet[FindIntegerNullVector[Join[logTally[[All,1]],{I \[Pi]}]]]; (* FindIntegerNullVector gives a warning message if it cannot decide if the relation is actually true. We do not rely on the fact that the relation is actually correct, because we use linearComboOfLogQ to prove that it is true. *)
(* check that a relation has been found: *)
If[Head[rel]===FindIntegerNullVector,  Return[expr, Module]]; 
relExpr = rel . Join[logTally[[All,1]],{I \[Pi]}];
If[linearComboOfLogZeroQ[relExpr]=!= True,Message[getRidOfOneLogArgument::couldnotprove,relExpr]; Return[expr,Module]];
relPos =Flatten@Position[rel[[;;-2]],Except[0],1,Heads->False];
leastCommonLog = Min[logTally[[relPos,2]]]; (* We use the relation to replace the log that appears least often. This is not crucial for the routine, but it helps to avoid getting very long expression. *)
logToReplace = First@First@Select[logTally[[relPos]], #[[2]]===leastCommonLog&];
logPrefactor=Coefficient[relExpr,logToReplace];
rule = {logToReplace -> logToReplace-Expand[relExpr/logPrefactor]};
Expand[expr/.rule]
];

(* LogSimplify[expr_]:= FixedPoint[getRidOfOneLogArgument,expr]; *)

logsRemaining[expr_]:=Length@Union@Cases[expr,Log[a_]:>a,{0,\[Infinity]}];
LogSimplify[expr_]:=Module[
{temp, result},
temp=PrintTemporary["Different logs remaining: ",logsRemaining[expr]];
result=FixedPoint[
Function[NotebookDelete[temp];
temp=PrintTemporary["Different logs remaining: ",logsRemaining[#]];
getRidOfOneLogArgument[#]]
,
expr,
logsRemaining[expr]+1 (* is an upper bound for the number of iterations*)
];
NotebookDelete[temp];
result
];


(* ::Subsection::Closed:: *)
(*Preprocessing Polylogarithms*)


(* ::Input::Initialization:: *)
convertImLi2toD2[expr_]:=expr/.ImLi2[z_]:>sD2[z]-1/2 Log[z*Conj[z]]*(Log[1-z]-Log[1-Conj[z]])/(2I);
convertReLi3toD3[expr_]:=expr/.{ReLi3[1]:>sD3[1],
ReLi3[z_]:>sD3[z]+1/2 Log[z*Conj[z]]sReLi2[z]+(Log[1-z]+Log[1-Conj[z]])/24 Log[z *Conj[z]]^2};


(* ::Input::Initialization:: *)
convertToLiWithNumberField[expr_,numberFieldGenerator_]:=TrigToExp[expr]/.{
Log[a_]:>Log[ToNumberField[a,numberFieldGenerator]],
PolyLog[2,a_]:>Li2[ToNumberField[a,numberFieldGenerator]],Catalan:>-I Li2[ToNumberField[I,numberFieldGenerator]]-(I \[Pi]^2)/48,
PolyLog[3,a_]:>Li3[ToNumberField[a,numberFieldGenerator]],
Zeta[3]:>Li3[1]
};
PreprocessTrilogsAndDilogs[expr_,numberFieldGenerator_]:=Module[{newExpr},
PrintTemporary["Converting the arguments of the (Poly-)Logs to the number field (may take some time)..."];
newExpr =convertToLiWithNumberField[expr,numberFieldGenerator];
PrintTemporary["Seperating the trilogs into real and imaginary part..."];
newExpr =newExpr /. Li3[x_]:>sReLi3[x]+I sImLi3[x];
PrintTemporary["Convert ReLi3[z] to expression with D3[z]..."];
newExpr = convertReLi3toD3[newExpr];
PrintTemporary["Seperating the dilogs into real and imaginary part..."];
newExpr = newExpr/.Li2[x_]:>sReLi2[x]+I sImLi2[x];
PrintTemporary["Convert ImLi2[z] to expression with D2[z]..."];
newExpr = convertImLi2toD2[newExpr];
newExpr
];


(* ::Subsection::Closed:: *)
(*Functional Equations for Polylogarithms*)


(* ::Input::Initialization:: *)
DuplicationRelationD2[z_]:=2D2[z]+2D2[-z]-D2[z^2];
FiveTermRelationD2[x_,y_]:=If[x===1||y===1,Nothing,D2[x]+D2[y]-D2[x/(1-y)]-D2[y/(1-x)]+D2[(x y)/((1-x)(1-y))]]; (* I recently added the untested If. But should work. Should not change anything, because D2[real number] is automatically reduced to 0. *)


(* ::Input::Initialization:: *)
DuplicationRelationD3[z_]:=4 D3[-z]+4 D3[z]-D3[z^2];
(* If a relation does not apply to the arguments given (e.g. because that leads to division by zero), the relations returns Nothing *)
NineTermRelationD3[x_,y_]:=If[x===1||y===1,Nothing,2 D3[1]-2 D3[x]-2 D3[(1-1/y)/(1-1/x)]-2 D3[(1-1/y)/(1-x)]-2 D3[(1-y)/(1-1/x)]-2 D3[(1-y)/(1-x)]+D3[x/y]+D3[(x (1-y)^2)/((1-x)^2 y)]-2 D3[y]+D3[x y]];
ThreeTermRelationD3[x_]:=If[x===1,Nothing,-D3[1]+D3[1-1/x]+D3[1-x]+D3[x]]; 
TwentyTwoTermRelationD3[a_,b_,c_]:=With[{x=1-c+b c, y=1-a+a c,z=1-b+a b},If[x===0||y===0||z===0,Nothing,

-3 D3[1]+D3[a]+D3[b]+D3[c]+D3[-a b c]+D3[(b c)/x]+D3[x]-D3[x/b]+D3[(a c)/y]+D3[-((a x)/y)]+D3[x/(b y)]-D3[x/(b c y)]+D3[y]-D3[y/c]+D3[(a b)/z]+D3[-((b y)/z)]+D3[y/(c z)]-D3[y/(a c z)]+D3[z]-D3[z/a]+D3[z/(a x)]-D3[z/(a b x)]+D3[-((c z)/x)]]];


(* ::Input::Initialization:: *)
rootsOfUnityInNumberField[n_,generator_]:=(
rootsOfUnityInNumberField[n,generator]=With[{root=ToNumberField[Exp[(2\[Pi] I)/n],generator]},Table[root^i,{i,1,n}]]);
DistributionRelationD2[n_, generator_][x_]:=With[
{roots=rootsOfUnityInNumberField[n,generator]},
D2[x^n]-n*Sum[D2[x*roots[[i]]],{i,1,n}]
];
DistributionRelationD3[n_, generator_][x_]:=With[
{roots=rootsOfUnityInNumberField[n,generator]},
D3[x^n]-n^2*Sum[D3[x*roots[[i]]],{i,1,n}]
];

GetDistributionRelationsD2[hightestRootOfUnity_,generator_]:=Module[
{divisors=Divisors[hightestRootOfUnity]},
Table[{DistributionRelationD2[div,generator],1},{div,divisors[[2;;]]}]
];

GetDistributionRelationsD3[hightestRootOfUnity_,generator_]:=Module[
{divisors=Divisors[hightestRootOfUnity]},
Table[{DistributionRelationD3[div,generator],1},{div,divisors[[2;;]]}]];


(* ::Subsection::Closed:: *)
(*Independent Relations*)


(* ::Input::Initialization:: *)
selectTerms[expr_,function_]:=Select[Collect[expr,function[_]],MatchQ[#,_. function[_]]&];
toAssoc[expr_,function_]:=Association@Cases[Collect[expr,function[_]], a_. function[z_]:> (z->a),{0,1}]; 

normalizeAssoc[assoc_]:=Map[#/(KeySort@assoc)[[1]]&,KeySort@assoc];(* to compare if two associations represent relations that are multiples of each other, we normalize them by setting the first coefficient to 0. Note that we make the associations canonically orderd, so two associations with the same keys have also the same first key. *)

getAllRelationsWithContractions[relationList_,relatedArgumentsFunction_]:=Apply[
Join,
Function[{rel, numberOfInputs},
Block[
{subsets = Tuples[Apply[Join,(relatedArgumentsFunction/@Array[Slot,numberOfInputs])],{numberOfInputs}],args},
args=Select[subsets,
Function[{x},
With[{slotsIndices = DeleteDuplicates[Cases[x,Slot[i_]:>i,{0,\[Infinity]}]]},Length[slotsIndices]==Max[slotsIndices]]
]
];
ReleaseHold[Function/@(Hold[rel]@@@args)/.Conjugate:>Hold[Conj]]]
]@@@relationList
]; (* copied from fullProof *)

IndependentRelationsWithContractions[relationList_,relatedArgumentsFunction_,function_->symmetrizedFunction_,generator_:Sqrt[-1]]:=Module[
{allRelations = getAllRelationsWithContractions[relationList,relatedArgumentsFunction],
maxNumberOfInputs = Max[relationList[[All,2]]],
testNumbers,
relationsAssoc,
groups},

testNumbers = ToNumberField[#,generator]&/@Table[Floor@Mod[10^(8n-4) Pi,10^4]+generator Floor@Mod[10^(8n) Pi,10^4],{n,1,maxNumberOfInputs}]; 
(* testNumbers should be sufficiently general numbers with no surprising relations *)
relationsAssoc = MapIndexed[
Function[{rel, index},
With[{result=ReplaceAll[rel@@testNumbers,function->symmetrizedFunction]},If[result===Nothing,Nothing,{normalizeAssoc@toAssoc[result,function],First@index}]]], 
allRelations
]; 

(* the Nothing check handles the case where the relation is applied to inputs where it does not make sense. TODO: I think this is not necessary here *)
groups=GroupBy[relationsAssoc, First->Last,First];

Function[{x},{x,Max[Cases[x,Slot[i_]:>i,{0,\[Infinity]}]]}]/@allRelations[[Values@groups]]
];


(* ::Input::Initialization:: *)
EquivalentArgumentsLi2::usage= "EquivalentArgumentsLi2[z] gives the list {z,1/z,1-z,1/(1-z),z/(z-1),1-1/z}";
EquivalentArgumentsLi3::usage="EquivalentArgumentsLi3[z] gives the list {z,1/z}";
EquivalentArgumentsD2::usage = "EquivalentArgumentsD2[z] gives the list Join[A,Conj/@A] where A={z,1/z,1-z,1/(1-z),z/(z-1),1-1/z}.";
EquivalentArgumentsD3::usage = "EquivalentArgumentsD3[z] gives the list {z,1/z,Conj[z],Conj[1/z]}.";
EquivalentArgumentsLi2[z_]:={z,1/z,1-z,1/(1-z),z/(-1+z),1-1/z};
EquivalentArgumentsLi3[z_]:={z,1/z};
EquivalentArgumentsD2[z_]:={z,1/z,1-z,1/(1-z),z/(-1+z),1-1/z,Conj[z],1/Conj[z],1-Conj[z],1/(1-Conj[z]),Conj[z]/(-1+Conj[z]),1-1/Conj[z]};

EquivalentArgumentsD3[z_]:={z,1/z,Conj[z],1/Conj[z]};


(* ::Input:: *)
(*Iconize[IndependentRelationsWithContractions[{{DuplicationRelationD2, 1},{FiveTermRelationD2,2}},EquivalentArgumentsD2,D2->sD2],"all relations D2"]*)


(* ::Input:: *)
(*Iconize[IndependentRelationsWithContractions[{{DuplicationRelationD2, 1},{FiveTermRelationD2,2}},EquivalentArgumentsLi2,D2->sD2NoConj],"all relations D2 no conjugate"]*)


(* ::Input:: *)
(*Iconize[IndependentRelationsWithContractions[{{ThreeTermRelationD3, 1},{DuplicationRelationD3, 1},{NineTermRelationD3, 2},{TwentyTwoTermRelationD3, 3}},EquivalentArgumentsD3,D3->sD3],"all relations D3"]*)


(* ::Input:: *)
(*Iconize[IndependentRelationsWithContractions[{{ThreeTermRelationD3, 1},{DuplicationRelationD3, 1},{NineTermRelationD3, 2}},EquivalentArgumentsD3,D3->sD3],"all relations except 22 term D3"]*)


(* ::Input:: *)
(*Iconize[*)
(*Select[*)
(*IndependentRelationsWithContractions[{{ThreeTermRelationD3, 1},{DuplicationRelationD3, 1},{NineTermRelationD3, 2},{TwentyTwoTermRelationD3, 3}},EquivalentArgumentsD3,D3->sD3],*)
(*Last[#]<3&],*)
(*"all relations except 3 param relations D3"]*)


(* ::Input::Initialization:: *)
AllRelationsD2 = {{PolyLogSimplify`DuplicationRelationD2[#]& , 1}, {PolyLogSimplify`DuplicationRelationD2[1 - #]& , 1}, {PolyLogSimplify`DuplicationRelationD2[(-1 + #)^(-1) #]& , 1}, {PolyLogSimplify`FiveTermRelationD2[#, #^(-1)]& , 1}, {PolyLogSimplify`FiveTermRelationD2[#, 1 - #]& , 1}, {PolyLogSimplify`FiveTermRelationD2[#, PolyLogSimplify`AlgebraicConjugate[#]^(-1)]& , 1}, {PolyLogSimplify`FiveTermRelationD2[#, 1 - PolyLogSimplify`AlgebraicConjugate[#]]& , 1}, {PolyLogSimplify`FiveTermRelationD2[#, #2]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, #2^(-1)]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, 1 - #2]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, (1 - #2)^(-1)]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, (-1 + #2)^(-1) #2]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, 1 - #2^(-1)]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, 1 - PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, (1 - PolyLogSimplify`AlgebraicConjugate[#2])^(-1)]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, (-1 + PolyLogSimplify`AlgebraicConjugate[#2])^(-1) PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, 1 - PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}};
AllRelationsD2NoConj={{PolyLogSimplify`DuplicationRelationD2[#]& , 1}, {PolyLogSimplify`DuplicationRelationD2[1 - #]& , 1}, {PolyLogSimplify`DuplicationRelationD2[(-1 + #)^(-1) #]& , 1}, {PolyLogSimplify`FiveTermRelationD2[#, #^(-1)]& , 1}, {PolyLogSimplify`FiveTermRelationD2[#, 1 - #]& , 1}, {PolyLogSimplify`FiveTermRelationD2[#, #2]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, #2^(-1)]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, 1 - #2]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, (1 - #2)^(-1)]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, (-1 + #2)^(-1) #2]& , 2}, {PolyLogSimplify`FiveTermRelationD2[#, 1 - #2^(-1)]& , 2}};
AllRelationsD3 = {{ThreeTermRelationD3[#]& , 1}, {PolyLogSimplify`DuplicationRelationD3[#]& , 1}, {PolyLogSimplify`NineTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#]]& , 1}, {PolyLogSimplify`NineTermRelationD3[#, #2]& , 2}, {PolyLogSimplify`NineTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, #]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, #^(-1)]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, PolyLogSimplify`AlgebraicConjugate[#]]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, PolyLogSimplify`AlgebraicConjugate[#]^(-1)]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #^(-1), PolyLogSimplify`AlgebraicConjugate[#]]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #^(-1), #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #^(-1), PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#], #^(-1)]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#], #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#], #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#], PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#], PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#]^(-1), #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#]^(-1), #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, #^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, PolyLogSimplify`AlgebraicConjugate[#]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, #3]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, #3^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, PolyLogSimplify`AlgebraicConjugate[#3]]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, PolyLogSimplify`AlgebraicConjugate[#3]^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), PolyLogSimplify`AlgebraicConjugate[#]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), #3]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), #3^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), PolyLogSimplify`AlgebraicConjugate[#3]]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), PolyLogSimplify`AlgebraicConjugate[#3]^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], #^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], #3]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], #3^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], PolyLogSimplify`AlgebraicConjugate[#3]]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], PolyLogSimplify`AlgebraicConjugate[#3]^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), #3]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), #3^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), PolyLogSimplify`AlgebraicConjugate[#3]]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), PolyLogSimplify`AlgebraicConjugate[#3]^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #3, #2]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #3, #2^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #3, PolyLogSimplify`AlgebraicConjugate[#2]]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #3, PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #3^(-1), #2]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #3^(-1), #2^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #3^(-1), PolyLogSimplify`AlgebraicConjugate[#2]]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #3^(-1), PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#3], #2]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#3], #2^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#3], PolyLogSimplify`AlgebraicConjugate[#2]]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#3], PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#3]^(-1), #2]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#3]^(-1), #2^(-1)]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#3]^(-1), PolyLogSimplify`AlgebraicConjugate[#2]]& , 3}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#3]^(-1), PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 3}};
AllRelationsD3Except22Term = {{ThreeTermRelationD3[#]& , 1}, {PolyLogSimplify`DuplicationRelationD3[#]& , 1}, {PolyLogSimplify`NineTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#]]& , 1}, {PolyLogSimplify`NineTermRelationD3[#, #2]& , 2}, {PolyLogSimplify`NineTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}};
AllRelationsD3Except3Param = {{ThreeTermRelationD3[#]& , 1}, {PolyLogSimplify`DuplicationRelationD3[#]& , 1}, {PolyLogSimplify`NineTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#]]& , 1}, {PolyLogSimplify`NineTermRelationD3[#, #2]& , 2}, {PolyLogSimplify`NineTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, #]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, #^(-1)]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, PolyLogSimplify`AlgebraicConjugate[#]]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, PolyLogSimplify`AlgebraicConjugate[#]^(-1)]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #, PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #^(-1), PolyLogSimplify`AlgebraicConjugate[#]]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #^(-1), #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #^(-1), PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#], #^(-1)]& , 1}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#], #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#], #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#], PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#], PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#]^(-1), #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#]^(-1), #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, #^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, PolyLogSimplify`AlgebraicConjugate[#]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2, PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), PolyLogSimplify`AlgebraicConjugate[#]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, #2^(-1), PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], #^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2], PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), #2]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), #2^(-1)]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), PolyLogSimplify`AlgebraicConjugate[#2]]& , 2}, {PolyLogSimplify`TwentyTwoTermRelationD3[#, PolyLogSimplify`AlgebraicConjugate[#2]^(-1), PolyLogSimplify`AlgebraicConjugate[#2]^(-1)]& , 2}};


(* ::Input::Initialization:: *)
(* adds a term to the relation that serves as a certificate. *)
addCertificate[relation_Function]:=relation/.Function[body_[args__]]:>Function[body[args] - Certificate[body][args]];
addAllCertificates[relationList_]:={addCertificate[First[#]],Last[#]}&/@relationList;


(* ::Subsection::Closed:: *)
(*Algebraic Condition for Bloch Groups*)


(* ::Input::Initialization:: *)
FindMultiplicativeEltRelation::wrong="Relation does not hold.";
FindMultiplicativeEltRelation::norelation="No numerical relation found.";
FindMultiplicativeEltRelation::complexcoeffs = "Integer nullvector contains complex coefficients";
FindMultiplicativeEltRelation::usage="FindMultiplicativeEltRelation[{\!\(\*SubscriptBox[\(a\), \(1\)]\),\!\(\*SubscriptBox[\(a\), \(2\)]\),...}] returns a rule MultElt[\!\(\*SubscriptBox[\(a\), \(k\)]\)] -> \!\(\*SubscriptBox[\(r\), \(1\)]\) MultElt[\!\(\*SubscriptBox[\(a\), SubscriptBox[\(i\), \(1\)]]\)] + ... \!\(\*SubscriptBox[\(r\), \(l\)]\) MultElt[\!\(\*SubscriptBox[\(a\), SubscriptBox[\(i\), \(l\)]]\)] with rational \!\(\*SubscriptBox[\(r\), \(1\)]\) if \!\(\*SubscriptBox[\(a\), \(k\)]\)=\!\(\*SuperscriptBox[SubscriptBox[\(a\), SubscriptBox[\(i\), \(1\)]], SubscriptBox[\(r\), \(1\)]]\)...\!\(\*SuperscriptBox[SubscriptBox[\(a\), SubscriptBox[\(i\), \(l\)]], SubscriptBox[\(r\), \(l\)]]\) up to torsion.";

(* The returned rule is proven to be correct. *)
FindMultiplicativeEltRelation[numbers_]:=Module[
{nullVector,
index,
relation
},

nullVector =Quiet[Check[
FindIntegerNullVector[Join[{2\[Pi] I},Log/@numbers]],
Message[FindMultiplicativeEltRelation::norelation];Return[$Failed,Module],
{FindIntegerNullVector::rnfu}
],{FindIntegerNullVector::rnfu,FindIntegerNullVector::ztest1,FindIntegerNullVector::ztest}];

(* Sometimes, FindIntegerNullVector gives an integer nullvector with complex coefficients. As long as all coefficients are purely imaginary, this is fine. *)
If[AnyTrue[Im/@nullVector,#=!=0&],nullVector = Im[nullVector]];
If[AnyTrue[Im/@nullVector,#=!=0&],FindMultiplicativeEltRelation::complexcoeffs; Return[$Failed,Module]];

(* Check if the relation actually holds. This is usally the case as FindIntegerNullVector rarely produces wrong results. *)
If[Times@@MapThread[Power,{numbers,nullVector[[2;;]]}]=!=1,
Message[FindMultiplicativeEltRelation::wrong];Return[$Failed,Module]
];

(* Return a rule to replace the first number appearing in the relation. *)
index =SelectFirst[Range[Length@nullVector-1],nullVector[[#+1]]!=0&];
relation=MultElt[numbers[[index]]]->-1/nullVector[[index+1]] Map[MultElt,numbers[[index+1;;]]] . nullVector[[index+2;;]];
relation
];

ReduceDimensionMultiplicativeElt::usage="ReduceDimensionMultiplicativeElt[{a_1,a_2,...}] returns {{a_{i_1},...,a_{i_l}},{a_{j_1}->...,...}} where a_{i_1},...,a_{i_l} should be linearly independent (under multiplication) and {a_{j_1}->...,...} are rules for the other numbers to write them as rational linear combinations of all MultElem[a_{i_k}], up to torsion.";
ReduceDimensionMultiplicativeElt[numbers_]:=Module[{
updatedNumbers = numbers,
relation,
allRelations = {},
guard=Length@numbers+1 (* Only to avoid infinite loop if something goes does not work. *)
},
While[
Quiet[Check[relation = FindMultiplicativeEltRelation[updatedNumbers],False,FindMultiplicativeEltRelation::norelation],FindMultiplicativeEltRelation::norelation]=!=False&& guard>0,

updatedNumbers = DeleteCases[updatedNumbers,First@relation/.MultElt[a_]:>a,1];

allRelations=allRelations/.relation;
AppendTo[allRelations, relation];
guard--
];
{updatedNumbers,allRelations}
];


(* ::Input::Initialization:: *)
Beta2[expr_]:=expr/.{D2[1]->0,D2[0]->0,D2[z_]:>TensorProduct[MultElt[z],MultElt[1-z]]-TensorProduct[MultElt[1-z],MultElt[z]]};
Beta3[expr_]:=expr/.{D3[1]->0,D3[0]->0,D3[z_]:>TensorProduct[MultElt[z],MultElt[z],MultElt[1-z]]-TensorProduct[MultElt[z],MultElt[1-z],MultElt[z]]};
SymmetrizeConjugateD2[expr_]:=expr/.D2[z_]:>1/2 (D2[z]-D2[Conj[z]]);
SymmetrizeConjugateD3[expr_]:=expr/.D3[z_]:>1/2 (D3[z]+D3[Conj[z]]);

TensorSimplifyMultiplicativeNumbersOneStep[expr_]:=Module[
{numbers,rule},
numbers = Union@Cases[expr,MultElt[a_]:>a,{0,\[Infinity]}];
If[Length@numbers==0,Return[expr,Module]];

rule =Quiet[Check[FindMultiplicativeEltRelation[numbers],None,FindMultiplicativeEltRelation::norelation],FindMultiplicativeEltRelation::norelation];
If[rule===None,Return[expr,Module]]; 
TensorExpand[expr/.rule]
];
(*TensorSimplifyMultiplicativeNumbers[expr_]:=FixedPoint[TensorSimplifyMultiplicativeNumbersOneStep,expr,Length@Union@Cases[expr,MultElt[a_]:>a,{0,\[Infinity]}]];
*)
numbersRemaining[expr_]:=Length@Union@Cases[expr,MultElt[a_]:>a,{0,\[Infinity]}];
TensorSimplifyMultiplicativeNumbers[expr_]:=Module[
{temp, result},
temp=PrintTemporary["Different numbers remaining: ",numbersRemaining[expr]];
result=FixedPoint[
Function[NotebookDelete[temp];
temp=PrintTemporary["Different numbers remaining: ",numbersRemaining[#]];
TensorSimplifyMultiplicativeNumbersOneStep[#]]
,
expr,
Length@Union@Cases[expr,MultElt[a_]:>a,{0,\[Infinity]}]
];
NotebookDelete[temp];
result
];

(* As a safeguard agaings infinite repitition if somethings goes wrong, bound the maximum iterations by the number of multiplicative elements. *)


(* ::Input::Initialization:: *)
ElementOfG2[expr_]:=TensorSimplifyMultiplicativeNumbers[Beta2[expr]]==0;
ElementOfA2[expr_]:=ElementOfG2[expr];

ZeroInB2[expr_]:=Module[{result =SimplifyAllTermsOneIteration[expr,AllRelationsD2NoConj,D2->sD2NoConj]},True/;result===0];

ElementOfG3[expr_]:=TensorSimplifyMultiplicativeNumbers[Beta3[expr]]==0;
ElementOfA3[expr_]:=Module[{
temp,
args,
reducedArgs,
rules,
homomorphisms,
applyHomomorphism,
dilogExpressionsToCheck,
result
},
temp=PrintTemporary["Checking if expression is in G3..."];
If[ElementOfG3[expr]!=True,Print["Cannot even prove that it is an element of G3."]; Return[False,Module]]; 
NotebookDelete[temp];

args = Keys@toAssoc[expr,D3];
{reducedArgs,rules} = ReduceDimensionMultiplicativeElt[args];

homomorphisms = Table[AssociationThread[reducedArgs->IdentityMatrix[Length@reducedArgs][[i]]],{i,Length@reducedArgs}];

applyHomomorphism[arg_,hom_]:=(MultElt[arg]/.rules)/.MultElt[a_]:>hom[a];

dilogExpressionsToCheck=Table[expr/.D3[a_]:>applyHomomorphism[a,hom]*D2[a],{hom,homomorphisms}];
PrintTemporary["Checking that ",Length@dilogExpressionsToCheck, " expressions are zero in B2..."];
AllTrue[dilogExpressionsToCheck,ZeroInB2]
];


(* ::Subsection::Closed:: *)
(*Expand Tensor Of Rational Functions*)


(* ::Input::Initialization:: *)
multExpandRules={
HoldPattern[MultElt[Times[args__]]]:>Total[MultElt/@{args}],
HoldPattern[MultElt[Power[base_,exp_]]]:>exp*MultElt[base],
MultElt[1]->0,
MultElt[-1]->0
};
isNegativePower[expr_]:=If[NumericQ[expr],Negative[expr],False];
isNegativeMonomial[expr_]:=If[Head[expr]===Times,isNegativePower[First[expr]],isNegativePower[expr]];
isNegative[expr_]:=If[Head[expr]===Plus,isNegativeMonomial[First@expr],isNegativeMonomial[expr]];
torsionRule={
MultElt[arg_?isNegative]:>MultElt[-arg]
};

TensorExpandRationalFunctions[expr_]:=TensorExpand[expr/.MultElt[x_]:>MultElt[Factor[x]]//.multExpandRules /.torsionRule];


(* ::Input:: *)
(*Block[{x},TensorExpandRationalFunctions[Beta3[ThreeTermRelationD3[x]]]]*)


(* ::Input:: *)
(*Block[{x,y},TensorExpandRationalFunctions[Beta3[NineTermRelationD3[x,y]]]]*)


(* ::Input:: *)
(*Block[{x,y,z},TensorExpandRationalFunctions[Beta3[TwentyTwoTermRelationD3[x,y,z]]]]*)


(* ::Input:: *)
(*Block[{x,y},TensorExpandRationalFunctions[Beta2[FiveTermRelationD2[x,y]]]]*)


(* ::Input:: *)
(*Block[{x},TensorExpandRationalFunctions[Beta2[DuplicationRelationD2[x]]]]*)


(* ::Input:: *)
(*Block[{x},TensorExpandRationalFunctions[Beta3[DuplicationRelationD3[x]]]]*)


(* ::Subsection:: *)
(*Relation Generation*)


(* ::Input::Initialization:: *)
(* Given a relation {f, n} and a list of arguments {z_1, ..., z_k}, returns a list of f[z_{i_1}, z_{i_2}, ..., z_{i_n}] for all ordered tuples (i_1,...,i_m) in {1,...,k} *)

generateRelationsForOneRel[listOfArguments_,relation_]:=With[{relationFunction=relation[[1]],numberOfInputs=relation[[2]]},
Replace[ResourceFunction["MonitorProgress"]@Map[relationFunction@@#&,Subsets[listOfArguments,{numberOfInputs}]],Nothing+_->Nothing,{1}]]; 
(* The replace is there to handle the case where a relation returns Nothing but the certificate was added. *)
(* NOTE: weirdly enough, defining monitor = ResourceFunction["MonitorProgress"] and then using monitor does not work, then map gets evaluated before the pattern for ResourceFunction["MonitorProgress"] [Map[...]] is applied. Do not fully understand this.*)
(* this is a bit inefficient because the large list of subsets is generated at once even though it is not needed. An iterative approach would be better, but somehow mathematica is not build for this. *)
generateRelations[listOfArguments_, listOfRelations_]:=Join@@ResourceFunction["MonitorProgress"][Map[generateRelationsForOneRel[listOfArguments, #]&,listOfRelations]];
(* generateRelations[{a,b,c},{{f,2},{g,1}}] gives
{f[a,b],f[a,c],f[b,c],g[a],g[b],g[c]} *)


(* ::Subsection:: *)
(*Greedy Local Search Simplification*)


(* ::Input::Initialization:: *)
(* This takes to associations of the form (argument of Li2) -> coefficient, one for the target expression and one for the relation. If computes the optimal multiple of the relation that should be subtracted to reduce the number of terms. In most cases, this will be 0, i.e. the relation cannot be used to simplify. The module returns a list {optimal multiple of relation to subtract, number of Li2 terms that will vanish in total after subtracting the relation =: reduction number}*)
optimalMultipleForReduction[targetAssoc_,relationAssoc_]:=Module[
{quotients, optimalMultiple},
If[Length@relationAssoc==0,Return[{0,0},Module]];
quotients=KeyValueMap[
Function[{relArg,relCoeff},
If[KeyExistsQ[targetAssoc,relArg],Lookup[targetAssoc,relArg]/relCoeff,0]],
relationAssoc];
optimalMultiple=First@Commonest[quotients,1];
{optimalMultiple, Count[quotients,optimalMultiple]-Count[quotients,0]}
];
(* TODO: as it stands, depends on the order of the association and if a multiple can be subtracted without changing number of terms, is not determined wether 0 or a nonzero multiple will be returned. *)


(* ::Input::Initialization:: *)
Options[greedySimplifyOneStep]={ReturnCertificate->False};
greedySimplifyOneStep[expr_,listOfRelations_,function_->symmetrisedFunction_,opts:OptionsPattern[]]:=Module[
{exprSymm,
targetAssoc,
relations,
relationAssocs,
optimalMultiplesAndReductionNums,
reductionNums,
maxReductionNum,
indicesOfRelationsYieldingBestReduction,
chosenIndex,
multiple,
listOfRelationsCert},
listOfRelationsCert = If[OptionValue[ReturnCertificate],addAllCertificates@listOfRelations,listOfRelations];
exprSymm=Collect[expr/.function->symmetrisedFunction,function[_]];
targetAssoc=toAssoc[exprSymm,function];
PrintTemporary["Generating relations on ",Length@Keys@targetAssoc, " numbers"];
relations=generateRelations[Keys@targetAssoc,listOfRelationsCert];
relations = relations/.function->symmetrisedFunction;
relationAssocs = toAssoc[#,function]&/@relations;
optimalMultiplesAndReductionNums=optimalMultipleForReduction[targetAssoc,#]&/@relationAssocs;
reductionNums=optimalMultiplesAndReductionNums[[All,2]];
maxReductionNum=Max[reductionNums];

If[maxReductionNum==0,
(* Print["No one-step simplification found."]; *)
Return[exprSymm,Module]];
PrintTemporary["Subtracting relation to reduce the number of terms by ", maxReductionNum,"."];

indicesOfRelationsYieldingBestReduction = Flatten@Position[reductionNums,maxReductionNum];
(*Print["There are ", 
Length@indicesOfRelationsYieldingBestReduction, 
" relations that will reduce the number of terms by ",
maxReductionNum, 
". Choosing the first one arbitrarily."];*)
chosenIndex = First@indicesOfRelationsYieldingBestReduction;
multiple = optimalMultiplesAndReductionNums[[chosenIndex, 1]];
(*Print["Subtracting ", multiple*relations[[chosenIndex]],"."];*)
exprSymm-Expand[multiple*relations[[chosenIndex]]]
];
Options[GreedySimplify]={ReturnCertificate->False};
GreedySimplify[expr_,listOfRelations_,function_->symmetrisedFunction_,opts:OptionsPattern[]]:=FixedPoint[greedySimplifyOneStep[#,listOfRelations,function->symmetrisedFunction,ReturnCertificate->OptionValue[ReturnCertificate]]&,
expr,
Length@toAssoc[expr,function]];


(* ::Subsection::Closed:: *)
(*Seperate Into Zero Subexpressions Numerically*)


(* ::Input::Initialization:: *)
seperateZeroSubexpressionOneStep[expr_,function_->symmetrisedFunction_,numericalFunction_]:=Module[
{exprSymm,
targetAssoc,
relation,
multiple,
functionTermsList,
nullVector},
exprSymm=Collect[expr/.function->symmetrisedFunction,function[_]];
targetAssoc=toAssoc[exprSymm,function];
If[Length@targetAssoc==0,Return[exprSymm,Module]];
functionTermsList=Map[function,Keys@targetAssoc];
nullVector =Quiet@Check[
FindIntegerNullVector[functionTermsList/.function->numericalFunction],
Print["No integer nullvector found."];Return[exprSymm,Module],
FindIntegerNullVector::rnfu
];
relation=nullVector . functionTermsList;
multiple=First@optimalMultipleForReduction[targetAssoc,toAssoc[relation,function]];
Print["Subtracting ", multiple*relation,"."]; 
exprSymm-Expand[multiple*relation]+multiple*ZeroExpression[relation]
];

SeperateZeroSubexpression[expr_,function_->symmetrisedFunction_,numericalFunction_]:=FixedPoint[seperateZeroSubexpressionOneStep[#,function->symmetrisedFunction,numericalFunction]&,
expr,
13];


(* ::Subsection::Closed:: *)
(*Simplify all Terms in One Iteration*)


(* ::Input::Initialization:: *)
SimplifyAllTermsOneIteration::nosol = "No solution found.";
Options[SimplifyAllTermsOneIteration]={ReturnCertificate->False};
SimplifyAllTermsOneIteration[expr_,listOfRelations_,function_->symmetrisedFunction_,opts:OptionsPattern[]]:=Module[
{exprSymm,
targetAssoc,
relations,
relationAssocs,
allArguments,
argumentToIndex,
targetVector,
relationVectors,
relationMatrix,
solutionVector,
listOfRelationsCert
},
listOfRelationsCert = If[OptionValue[ReturnCertificate],addAllCertificates@listOfRelations,listOfRelations];
(* put expr in association form and generate relations for all appearing arguments *)
exprSymm=Collect[expr/.function->symmetrisedFunction,function[_]];
targetAssoc=toAssoc[exprSymm,function];
If[Length@targetAssoc==0,Return[exprSymm,Module]];
relations=generateRelations[Keys@targetAssoc,listOfRelationsCert];
relations=relations/.function->symmetrisedFunction;
relationAssocs = toAssoc[#,function]&/@relations;

(* create an association that associates to each argument an index *)
allArguments=Union[Keys@targetAssoc,Union@@(Keys/@relationAssocs)];
argumentToIndex=AssociationThread[allArguments->Range[Length[allArguments]]];

(* use the argumentToIndex association to make the association to arrayRules which can directly be converted to sparse arrays *)
targetVector = SparseArray[
Normal@KeyMap[argumentToIndex,targetAssoc],
Length@allArguments];
relationVectors=KeyMap[argumentToIndex]/@relationAssocs;

relationMatrix = SparseArray[
Flatten@Table[{i,#}->relationVectors[[i]][#]&/@Keys[relationVectors[[i]]],{i,Length[relationVectors]}],
{Length@relations,Length@allArguments}];

solutionVector=Quiet[
Check[
LinearSolve[Transpose@relationMatrix,targetVector],
Message[SimplifyAllTermsOneIteration::nosol]; Return[exprSymm,Module],
LinearSolve::nosol],
LinearSolve::nosol];

exprSymm - Expand[solutionVector . relations]
];


(* ::Subsection:: *)
(*Simplify all Terms in Multiple Iterations*)


(* ::Input::Initialization:: *)
NewArgumentsFirstIteration[targetAssoc_,{}]:=Keys@targetAssoc;
NewArgumentsSecondIterationAll[targetAssoc_,{relationAssocs_}]:=Union[Keys@targetAssoc,Union@@Map[Keys,relationAssocs]];


containsFewNewTermsQ[relationAssoc_,maxIndexOfOldArgs_,cutoff_]:=Length@Select[Keys@relationAssoc,#>maxIndexOfOldArgs&]<=cutoff;

NewArgumentsSecondIterationWithCutoff[targetAssoc_,{relationAssocs_},cutoff_]:=Module[
{goodRelations,maxIndexOfTarget},
maxIndexOfTarget=Max[Keys@targetAssoc];
goodRelations=Select[relationAssocs,containsFewNewTermsQ[#,maxIndexOfTarget,cutoff]&];
Union[Keys@targetAssoc,Union@@Map[Keys,goodRelations]]
];



addOffsetToArrayRules[arrayRules_,offset_]:=({#[[1]][[1]]+offset,#[[1]][[2]]}->#[[2]])&/@arrayRules;

LinearSolveStandard::nosol="No solution.";
LinearSolveStandard[targetAssoc_,listOfRelationAssocs_]:=Module[
{numberOfArguments,offsets,targetVector,allRelations,relationMatrix,solution},
numberOfArguments = Table[Max[Keys/@relationAssocs],{relationAssocs,listOfRelationAssocs}];
offsets=Join[{0},Accumulate[Length/@listOfRelationAssocs]];
targetVector = SparseArray[Normal[targetAssoc],Last@numberOfArguments];
allRelations=Join@@listOfRelationAssocs;
relationMatrix =SparseArray[
Flatten@Table[
Map[{j,#}->allRelations[[j]][#]&,Keys[allRelations[[j]]]],
{j,Length[allRelations]}
],
{Length[allRelations],Last@numberOfArguments}
];
Print["Calling LinearSolve on matrix with dimension ",  Dimensions[relationMatrix]];
solution = Quiet[Check[
LinearSolve[Transpose@relationMatrix,targetVector],
Message[LinearSolveStandard::nosol]; Return[None,Module],
LinearSolve::nosol],
LinearSolve::nosol];

Table[solution[[offsets[[j]]+1;;offsets[[j+1]]]],{j,1,Length@listOfRelationAssocs}]
];

(* This solves a linear system while only considering good numbers and relations, in the sense defined by the function above. A cutoff of 1 is garuanteed to find a solution if it exists (because a relation containing a number that does not appear in any other relation is useless)*)
linearSolveDiscardRelationsWithRareArguments[relMatrix_, target_, cutoff_:1]:=Module[{goodNumbers,goodRelations, goodRelMatrix,goodTarget, goodSolution, totalSolution,maxIndexInTarget},
(* We do not want to discard numbers appearing in the targetVector. *)
maxIndexInTarget =Max[Flatten[Keys[ArrayRules[target][[;;-2]]]]];
{goodNumbers,goodRelations} = getGoodNumbersAndRels[relMatrix,maxIndexInTarget,cutoff];
Print["original dimension ", Dimensions[relMatrix]];
Print["new ", Length@goodRelations," ",Length@goodNumbers];
goodRelMatrix = relMatrix[[goodRelations,goodNumbers]];
goodTarget = target[[goodNumbers]];
Print["Calling LinearSolve on matrix with dimension ",Dimensions[goodRelMatrix]];
goodSolution = LinearSolve[Transpose[goodRelMatrix],goodTarget];
If[Head[goodSolution]===LinearSolve,Print["No solution."];Return[Nothing, Module]];
Print["Solution found."];
totalSolution = SparseArray[{},Length[relMatrix]];
totalSolution[[goodRelations]]= goodSolution;
totalSolution
]

(* TODO: test the fast functions from package v1 and put them here. *)

getGoodNumbersAndRels[relMatrix_, numbersToKeep_, cutoff_:1]:=Module[{goodNumbers,badNumbers,goodRelations,badRelations, maxIndexInTarget},
goodNumbers=ResourceFunction["MonitorProgress"][Select[Range[Dimensions[relMatrix][[2]]],#<=numbersToKeep||Length[(relMatrix[[All,#]])["NonzeroValues"]]>cutoff&]];
badNumbers =  Complement[Range[Dimensions[relMatrix][[2]]],goodNumbers];
badRelations = Keys[ArrayRules[relMatrix[[All,badNumbers]]][[;;-2]]][[All,1]]//DeleteDuplicates;
goodRelations = Complement[Range[Length[relMatrix]],badRelations];
{goodNumbers,goodRelations}
]


LinearSolveWithCutoff[targetAssoc_,listOfRelationAssocs_,maxNewArgumentsInRelation_,minRelationsWithArgument_]:=Module[
{numberOfArguments,
numbersOfArgumentsWithTarget,
offsets,
offsetsForGoodRelations,
targetVector,
goodRelationsIndices,
allRelations,
relationMatrix,
solution,
solutionVectors,
totalSolution},

numberOfArguments = Table[Max[Keys/@relationAssocs],{relationAssocs,listOfRelationAssocs}];
numbersOfArgumentsWithTarget=Join[Max@Keys[targetAssoc],numberOfArguments];

offsets=Join[{0},Accumulate[Length/@listOfRelationAssocs]];
Print["Orginally, have ", Last@offsets, " relations and ",Last@numberOfArguments, " arguments."];
targetVector = SparseArray[Normal[targetAssoc],Last@numberOfArguments];

goodRelationsIndices=Table[
Select[Range[Length[listOfRelationAssocs[[j]]]],containsFewNewTermsQ[listOfRelationAssocs[[j]][[#]],numbersOfArgumentsWithTarget[[j]],maxNewArgumentsInRelation[[j]]]&],
{j,Length@listOfRelationAssocs}];
offsetsForGoodRelations=Join[{0},Accumulate[Length/@goodRelationsIndices]];

allRelations=Join@@Table[
listOfRelationAssocs[[j]][[goodRelationsIndices[[j]]]],
{j,Length@listOfRelationAssocs}];

Print["After filtering relations, have ", Length@allRelations, " relations left."];

relationMatrix =SparseArray[
Flatten@Table[
{j,#}->allRelations[[j]][#]&/@Keys[allRelations[[j]]],
{j,Length[allRelations]}
],
{Length[allRelations],Last@numberOfArguments}
];

solution=linearSolveDiscardRelationsWithRareArguments[relationMatrix,targetVector,minRelationsWithArgument];
If[solution===Nothing,Return[None,Module]];
solutionVectors=Table[solution[[offsetsForGoodRelations[[j]]+1;;offsetsForGoodRelations[[j+1]]]],{j,1,Length@listOfRelationAssocs}];


totalSolution = Table[SparseArray[{},Length[listOfRelationAssocs[[j]]]],{j,Length@listOfRelationAssocs}];
Do[totalSolution[[j]][[goodRelationsIndices[[j]]]]=solutionVectors[[j]],{j,Length@listOfRelationAssocs}];

totalSolution
];


(* ::Input::Initialization:: *)
Options[SimplifyAllTerms]={ReturnCertificate->False};
SimplifyAllTerms::nosol = "No solution found.";
SimplifyAllTerms[expr_,plan_,function_->symmetrisedFunction_,opts:OptionsPattern[]]:=Module[
{useCert,
exprSymm,
targetAssoc,
targetAssocByIndex,
relations,
relationAssocs,
relationAssocsByIndex,
allArguments,
goodArgumentsIndices,
goodArguments,
argumentToIndex,
solutionVectors,
i,
date,
relationFunctions
},

useCert=OptionValue[ReturnCertificate];

(* put expr in association form and generate relations for all appearing arguments *)
Print["Preparing expression (collection functions terms and putting into association)..."];
exprSymm=Collect[expr/.function->symmetrisedFunction,function[_]];
targetAssoc=toAssoc[exprSymm,function];
If[Length@targetAssoc==0,Return[exprSymm,Module]];
allArguments =Keys@targetAssoc;
argumentToIndex=AssociationThread[allArguments->Range[Length[allArguments]]];
targetAssocByIndex =KeyMap[argumentToIndex,targetAssoc];
date = DateString[Now,{"Year","_","Month","_","Day","_","Hour","_","Minute","_","Second"}];

(* Print["Files will be stored under the datetime ", date];
Print["Exporting targetAssocByIndex..."];
Export["C:\\Users\\finnl\\OneDrive\\Studium\\Bachelorarbeit\\Package\\exports\\"<>date<>"_targetAssocByIndex.mx",targetAssocByIndex]; *)

For[i=1,i<=Length[plan],i++,
Print["Starting iteration ",i];
Print["Selecting the numbers to use for relation generation..."];
goodArgumentsIndices=plan[[i]]["newArguments"][targetAssocByIndex,Table[relationAssocsByIndex[j],{j,1,i-1}]];
goodArguments=allArguments[[goodArgumentsIndices]];
Print["Starting relation generation on ",Length@goodArguments, " numbers."];
relationFunctions = If[useCert,addAllCertificates@plan[[i]]["relations"],plan[[i]]["relations"]];
relations[i]=generateRelations[goodArguments,relationFunctions]/.function->symmetrisedFunction;
Print["Generated ", Length@relations[i]," relations. Putting them in association form..."];
relationAssocs = toAssoc[#,function]&/@relations[i];

(* Joins newly introduced arguments into the list, while keeping the positions of the old arguments unchanged. This is important as it ensures that the old relation matrices and target vector are consistent. *)
allArguments=Join[allArguments,Complement[Union@@(Keys/@relationAssocs),allArguments]];
argumentToIndex=AssociationThread[allArguments->Range[Length[allArguments]]];
(* Print["Exporting argumentToIndex..."];
Export["C:\\Users\\finnl\\OneDrive\\Studium\\Bachelorarbeit\\Package\\exports\\"<>date<>"_allArgumemts_"<>ToString[i]<>".mx",allArguments]; *)

(* transforms the list of relations to be of type <|index -> prefactor|> instead of <|argument -> prefactor |>*)
relationAssocsByIndex[i] =Map[KeyMap[argumentToIndex],relationAssocs];
(*Print["Exporting relationAssocsByIndex[",i,"]..."];
Export["C:\\Users\\finnl\\OneDrive\\Studium\\Bachelorarbeit\\Package\\exports\\"<>date<>"_relationAssocsByIndex_"<>ToString[i]<>".mx",relationAssocsByIndex[i]];
Print["Starting to find solution..."];*)

solutionVectors =plan[[i]]["linearSolve"][targetAssocByIndex,Table[relationAssocsByIndex[j],{j,1,i}]];


If[solutionVectors=!=None,
Return[exprSymm-Expand[Sum[solutionVectors[[j]] . relations[j],{j,1,i}]],Module];
];
];

Message[SimplifyAllTerms::nosol];
exprSymm
];


(* ::Subsection:: *)
(*End Of Package*)


(* ::Input::Initialization:: *)
End[];
EndPackage[];
